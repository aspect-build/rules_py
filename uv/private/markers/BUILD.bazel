load("@bazel_skylib//rules:common_settings.bzl", "string_flag")
load(":defs.bzl", "configurable_string", "decide_marker")

# 'python_version'
#   {major}.{minor}
alias(
    name = "python_version",
    actual = "@rules_python//python/config_settings:python_version_major_minor",
    visibility = ["//visibility:public"],
)

# 'python_full_version'
#   {major}.{minor}.{patch}[...]
alias(
    name = "python_full_version",
    actual = "@rules_python//python/config_settings:python_version",
    visibility = ["//visibility:public"],
)

# 'os_name'
#   posix,
#   java,
configurable_string(
    name = "os_name",
    value = select({
        "@platforms//os:windows": "nt",
        "@platforms//os:macos": "posix",
        "@platforms//os:linux": "posix",
    }),
    visibility = ["//visibility:public"],
)

# 'sys_platform'
#   linux,
#   darwin,
#   java1.8.0_51
#   win32         # even on win64 lol
configurable_string(
    name = "sys_platform",
    value = select({
        "@platforms//os:windows": "win32",
        "@platforms//os:macos": "darwin",
        "@platforms//os:linux": "linux",
    }),
    visibility = ["//visibility:public"],
)

# 'platform_release'
#
# TODO: We don't really have a concept of target OS platform version, so we
# can't just do anything reasonable here. Mac versions sorta map to libsystem
# versions, but there's no clear way to get windows version strings or linux
# version strings. Likely need some new @platforms-like thing which would have
# some relation to the libc constraints repo.
#
# Set a garbage default value and let users set this as a flag.
string_flag(
    name = "os_release",
    build_setting_default = "<invalid>",
    visibility = ["//visibility:public"],
)

# 'platform_system'
configurable_string(
    name = "platform_system",
    value = select({
        "@platforms//os:windows": "Windows",
        "@platforms//os:macos": "Darwin",
        "@platforms//os:linux": "Linux",
    }),
    visibility = ["//visibility:public"],
)

# 'platform_version'
#
# TODO: This is actually a superset of the os_release string, but we don't have
# a good way to do this either for exactly the same reasons. Pretend they're the
# same and let the user configure a string.
alias(
    name = "platform_version",
    actual = ":os_release",
    visibility = ["//visibility:public"],
)

# 'platform_machine'
#   x86_64,
configurable_string(
    name = "platform_machine",
    value = select({
        "@platforms//cpu:x86_64": "x86_64",
        "@platforms//cpu:aarch64": "aarch64",
    }),
    visibility = ["//visibility:public"],
)

# 'platform_python_implementation'
#   CPython, Jython, [PyPy, IronPython, ...]
#
# TODO: We don't actually support this. CPython only. This should probably be a
# property of the Python toolchain.
configurable_string(
    name = "platform_python_implementation",
    value = "CPython",
    visibility = ["//visibility:public"],
)

# 'implementation_name'
#   cpython
#
# TODO: Same problem(s) as the platform_python_implementation.
configurable_string(
    name = "implementation_name",
    value = "cpython",
    visibility = ["//visibility:public"],
)

# 'implementation_version'
alias(
    name = "implementation_version",
    actual = ":python_full_version",
    visibility = ["//visibility:public"],
)

### Test markers
# TODO: Figure out a way to make these actual tests...

# { name = "jinxed", marker = "sys_platform == 'win32'" },
decide_marker(
    name = "test_jinxed",
    marker = "sys_platform == 'win32'",
)

# { name = "tomli", marker = "python_full_version <= '3.11'" },
decide_marker(
    name = "test_tomli",
    marker = "python_full_version <= '3.11'",
)

# { name = "cffi", marker = "platform_python_implementation != 'PyPy'" },
decide_marker(
    name = "test_cffi",
    marker = "platform_python_implementation != 'PyPy'",
)

# { name = "hf-xet", marker = "platform_machine == 'aarch64' or platform_machine == 'amd64' or platform_machine == 'arm64' or platform_machine == 'x86_64'" },
decide_marker(
    name = "test_hf_xet",
    marker = "platform_machine == 'aarch64' or platform_machine == 'amd64' or platform_machine == 'arm64' or platform_machine == 'x86_64'",
)

# { name = "appnope", marker = "sys_platform == 'darwin'" },
decide_marker(
    name = "test_appnope",
    marker = "sys_platform == 'darwin'",
)

# { name = "pexpect", marker = "sys_platform != 'emscripten' and sys_platform != 'win32'" },
decide_marker(
    name = "test_pexpect",
    marker = "sys_platform != 'emscripten' and sys_platform != 'win32'",
)

# { name = "pywin32", marker = "platform_python_implementation != 'PyPy' and sys_platform == 'win32'" },

# { name = "pywinpty", marker = "os_name == 'nt' and sys_platform != 'darwin' and sys_platform != 'linux'" },

# { name = "psutil", marker = "sys_platform != 'cygwin'" },

# { name = "gpustat", marker = "extra == 'dev'" },

# { name = "ipython", marker = "extra == 'dev'" },

# { name = "ruff", marker = "extra == 'dev'", specifier = ">=0.2.2" },
# { name = "tzdata", marker = "sys_platform == 'win32'" },
# { name = "psycopg-binary", marker = "implementation_name != 'pypy'" },
# { name = "evdev", marker = "'linux' in sys_platform" },
decide_marker(
    name = "test_evdev",
    marker = "'linux' in sys_platform",
)

# { name = "pyobjc-framework-applicationservices", marker = "sys_platform == 'darwin'" },
# { name = "pyobjc-framework-quartz", marker = "sys_platform == 'darwin'" },
# { name = "python-xlib", marker = "'linux' in sys_platform" },
# { name = "pyobjc-core", marker = "sys_platform == 'darwin'" },
# { name = "pyobjc-framework-cocoa", marker = "sys_platform == 'darwin'" },
# { name = "pyobjc-framework-coretext", marker = "sys_platform == 'darwin'" },
# { name = "pyobjc-framework-quartz", marker = "sys_platform == 'darwin'" },
# { name = "pyobjc-core", marker = "sys_platform == 'darwin'" },
# { name = "pyobjc-core", marker = "sys_platform == 'darwin'" },
# { name = "pyobjc-framework-cocoa", marker = "sys_platform == 'darwin'" },
# { name = "pyobjc-framework-quartz", marker = "sys_platform == 'darwin'" },
# { name = "pyobjc-core", marker = "sys_platform == 'darwin'" },
# { name = "pyobjc-framework-cocoa", marker = "sys_platform == 'darwin'" },
# { name = "colorama", marker = "sys_platform == 'win32'" },
# { name = "cffi", marker = "implementation_name == 'pypy'" },
# { name = "async-timeout", marker = "python_full_version < '3.11.3'" },
# { name = "ruamel-yaml-clib", marker = "platform_python_implementation == 'CPython'" },
# { name = "greenlet", marker = "platform_machine == 'AMD64' or platform_machine == 'WIN32' or platform_machine == 'aarch64' or platform_machine == 'amd64' or platform_machine == 'ppc64le' or platform_machine == 'win32' or platform_machine == 'x86_64'" },
decide_marker(
    name = "test_greenlet",
    marker = "platform_machine == 'AMD64' or platform_machine == 'WIN32' or platform_machine == 'aarch64' or platform_machine == 'amd64' or platform_machine == 'ppc64le' or platform_machine == 'win32' or platform_machine == 'x86_64'",
)

# { name = "watchdog", marker = "sys_platform != 'darwin'" },
# { name = "array-record", marker = "sys_platform == 'linux'" },
# { name = "ptyprocess", marker = "os_name != 'nt'" },
# { name = "pywinpty", marker = "os_name == 'nt' and sys_platform != 'darwin' and sys_platform != 'linux'" },
# { name = "colorama", marker = "sys_platform == 'win32'" },
# { name = "embreex", marker = "platform_machine == 'x86_64'" },
# { name = "colorama", marker = "sys_platform == 'win32'" },
# { name = "tzdata", marker = "sys_platform == 'win32'" },
# { name = "fasteners", marker = "sys_platform != 'emscripten'" },
# { name = "cffi", marker = "platform_python_implementation == 'PyPy'" },
